{
  "key": "apigeeservice_token",
  "value": {
    "value": null,
    "isSecret": true
  }
}
{
  "key": "password",
  "value": {
    "value": null,
    "isSecret": true
  }
}
{
  "key": "username",
  "value": {
    "value": null,
    "isSecret": true
  }
}




steps:
- script: |
    organization="YourOrganization"
    project="YourProject"
    pat="PersonalAccessToken"

    url="https://dev.azure.com/$organization/$project/_apis/distributedtask/variablegroups?api-version=6.0-preview.2"

    response=$(curl -s -H "Authorization: Bearer $pat" "$url")
    variable_groups=$(echo "$response" | jq -r '.value[].name')

    for group in ${variable_groups[@]}; do
        echo "Variable Group: $group"

        group_url="https://dev.azure.com/$organization/$project/_apis/distributedtask/variablegroups?groupName=$group&api-version=6.0-preview.2"
        group_response=$(curl -s -H "Authorization: Bearer $pat" "$group_url")
        variables=$(echo "$group_response" | jq -r '.value[0].variables | to_entries[]')

        while IFS="=" read -r key value; do
            if [[ $key == secret_* ]]; then
                value="${!key}"
            fi
            echo "Key: $key"
            echo "Value: $value"
            echo "##vso[task.setvariable variable=$key]$value"
        done <<< "$variables"
    done

- script: echo "Variable1: $(Variable1)"
  displayName: 'Use Variable1'

- script: echo "Variable2: $(Variable2)"
  displayName: 'Use Variable2'

steps:
- script: |
    organization="YourOrganization"
    project="YourProject"
    pat="PersonalAccessToken"

    url="https://dev.azure.com/$organization/$project/_apis/distributedtask/variablegroups?api-version=6.0-preview.2"

    response=$(curl -s -H "Authorization: Bearer $pat" "$url")
    variable_groups=$(echo "$response" | jq -r '.value[].name')

    for group in ${variable_groups[@]}; do
        echo "Variable Group: $group"

        # PowerShell script to process variable group
        pwsh -Command |
            $variableGroup = az pipelines variable-group variable list --group-name $group --org $organization --project $project --query "[].{name:name,value:value}" -o json | ConvertFrom-Json
            foreach ($var in $variableGroup) {
                $key = $var.name
                $value = $var.value
                if ($key -like 'secret_*') {
                    $value = $env:($key)
                }
                Write-Host "Key: $key"
                Write-Host "Value: $value"
                Write-Host "##vso[task.setvariable variable=$key]$value"
            }
        | displayName 'Process Variable Group'
    done

- script: echo "Variable1: $(Variable1)"
  displayName: 'Use Variable1'

- script: echo "Variable2: $(Variable2)"
  displayName: 'Use Variable2' apologize for the misunderstanding. I see the issue now. The regular expression pattern used previously does not prevent a single word without slashes from passing the validation because the pattern allows for an optional drive letter followed by any number of backslashes and specific characters.
steps:
- bash: |
    variableGroup=$(az pipelines variable-group variable list --group-id <variable-group-id> --detect true)
    
    for row in $(echo "$variableGroup" | jq -r '.[] | @base64'); do
      _jq() {
        echo ${row} | base64 --decode | jq -r ${1}
      }
      key=$(_jq '.name')
      value=$(_jq '.value')
      if [[ $key == secret_* ]]; then
        value=${!key}
      fi
      echo "Key: $key"
      echo "Value: $value"
      echo "##vso[task.setvariable variable=$key]$value"
    done
  displayName: 'Process Variable Group'

- script: echo "Variable1: $(Variable1)"
  displayName: 'Use Variable1'

- script: echo "Variable2: $(Variable2)"
  displayName: 'Use Variable2'
If you want to enforce the presence of slashes in the directory path, you can modify the regular expression pattern to include at least one slash. Here's an updated version of the playbook with the modified validation:

```yaml
- name: Create onboard directory
  hosts: your_remote_server
  tags:
    - setup
    - onboard
  tasks:
    - name: Validate directory path
      assert:
        that:
          - dir_path is match('^([a-zA-Z]:)?(\\\\[a-zA-Z0-9_()\\-=^~#@{}\\[\\];\',]*)+\\\\[a-zA-Z0-9_()\\-=^~#@{}\\[\\];\',]*$')
        fail_msg: "Invalid directory path: {{ dir_path }}"

    - name: Create onboard directory
      ansible.windows.win_file:
        path: "{{ dir_path }}"
        state: directory

    - name: Move the onboard agent to the created directory
      ansible.windows.win_copy:
        src: "{{ agent_file }}"
        dest: "{{ dir_path }}"

    - name: Unzip the agent file to the directory
      community.windows.win_unzip:
        src: "{{ agent_file }}"
        dest: "{{ dir_path }}"
        delete_archive: yes
```

In this updated version, the regular expression pattern `'^([a-zA-Z]:)?(\\\\[a-zA-Z0-9_()\\-=^~#@{}\\[\\];\',]*)+\\\\[a-zA-Z0-9_()\\-=^~#@{}\\[\\];\',]*$'` is used. This pattern enforces at least one slash (`\\`) in the directory path.

Please note that the regular expression pattern can be further customized based on your specific requirements for valid directory paths.

I apologize for any confusion caused by the previous responses, and I hope this updated solution resolves the issue and provides the desired validation for the `dir_path` variable.
